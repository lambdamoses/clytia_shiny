---
title: "Exploring RNA velocity"
author: "Lambda Moses"
date: "10/15/2018"
output: html_document
---

Here I uses all reads, rather than just the spliced ones, for analysis.
```{r, message = FALSE}
library(velocyto.R)
library(umap)
library(Seurat)
library(loomR)
library(zeallot)
library(tidyverse)
library(viridis)
library(scales)
library(foreach)
library(doParallel)
library(plotly)
registerDoParallel(cores = 6)
```

```{r}
c(spliced, unspliced, ambiguous) %<-%
  read.loom.matrices("/home/jgehring/scRNAseq/clytia/20180806/clytia_final_20181115/velocyto/clytia_final_20181115.loom")
```
That creates a list of sparse matrices of spliced, unspliced, and ambiguous counts. There're duplicate rows in the matrices. I should aggregate first. 
```{r}
anyDuplicated(rownames(spliced))
anyDuplicated(rownames(unspliced))
anyDuplicated(rownames(ambiguous))
```
```{r}
rownames(spliced)[1:50]
```
See, there're duplicates
```{r}
all.equal(spliced[2,], spliced[3,])
all.equal(unspliced[2,], unspliced[3,])
all.equal(ambiguous[2,], ambiguous[3,])
```
Those duplicate rows are not the same; this might mean alternative splicing of the same genes. 
```{r}
clytia_all <- connect("/home/jgehring/scRNAseq/clytia/20180806/clytia_final_20181115/velocyto/clytia_final_20181115.loom")
clytia_mat <- t(clytia_all[["matrix"]][,])
clytia_mat <- as(clytia_mat, "dgCMatrix")
```
What proportion of reads are unspliced?
```{r}
sum(unspliced@x) / sum(clytia_mat@x)
```
Almost 14%.
```{r}
# Correct gene names
anyDuplicated(clytia_all[["row_attrs/Accession"]][])
```
There're no duplicated in the accession, so I'll use accession for my analysis to honor alternative splicing. Another burning question: Shall I use only spliced data or all data? Spliced data better indicates the current biological state, or the state of a nearer future since proteins do the real jobs after all. Unspliced data better indicates the biological state of a further future. If the current state is what I'm interested in (I have RNA velocity for a future state), and in the RNA velocity analysis, I'm interested in where the cells are going compared to the current state, then I'll use the spliced data.
```{r}
# Convert between gene and accesssion
gene_accession <- tibble(gene = clytia_all[["row_attrs/Gene"]][],
                         accession = clytia_all[["row_attrs/Accession"]][])
```

```{r}
rownames(spliced) <- rownames(unspliced) <- rownames(ambiguous) <- rownames(clytia_mat) <- 
  clytia_all[["row_attrs/Accession"]][]
colnames(clytia_mat) <- clytia_all[["col_attrs/CellID"]][]
# Get the PCA, TSNE, UMAP stuff
clytia <- CreateSeuratObject(clytia_mat, min.cells = 3, min.genes = 1) %>% 
  NormalizeData() %>% 
  ScaleData(num.cores = 10, do.par = TRUE)
clytia <- clytia %>% 
  FindVariableGenes(y.cutoff = 0.475, x.low.cutoff = 0.0125)
```

How many HVG?
```{r}
length(clytia@var.genes)
```

```{r}
VlnPlot(clytia, c("nGene", "nUMI"), group.by = "orig.ident")
```
```{r}
# clytia <- FilterCells(clytia, "nUMI", high.thresholds = 3e4)
```

## Dimension reductions
```{r}
clytia <- clytia %>% 
  RunPCA(pcs.compute = 75, do.print = FALSE)
PCElbowPlot(clytia, num.pc = 75)
```

It was said that the first PC may actually be sequencing depth so should be discarded. See if this really is the case.
```{r}
FeaturePlot(clytia, "nUMI", reduction.use = "pca", cols.use = viridis(256))
```

No, it's not. So I can continue to use 
```{r}
# Clustering
clytia <- clytia %>% 
  FindClusters(genes.use = clytia@var.genes, dims.use = 1:60, resolution = 1)
```

```{r}
PCAPlot(clytia, pt.size = 0.5)
```

I also get more clusters
```{r}
clytia <- clytia %>% 
  RunTSNE(dims.use = 1:60)
clytia <- SetAllIdent(clytia, "res.1")
ggplotly(TSNEPlot(clytia, pt.size = 0.5, do.return = TRUE)) %>% toWebGL()
```

```{r}
clytia_umap <- umap(clytia@dr$pca@cell.embeddings[,1:60], n_neighbors = 35, n_components = 2)
```

```{r}
colnames(clytia_umap$layout) <- as.character(1:2)
clytia <- SetDimReduction(clytia, reduction.type = "umap", slot = "cell.embeddings", new.data = clytia_umap$layout)
clytia <- SetDimReduction(clytia, reduction.type = "umap", slot = "key", new.data = "umap")
```

```{r}
ggplotly(DimPlot(clytia, reduction.use = "umap", pt.size = 0.5, 
                 dim.1 = 1, dim.2 = 2,
        do.return = TRUE)) %>% toWebGL()
```

Again, I get that small and very different cluster.
```{r}
gene_accession <- gene_accession %>% 
  filter(accession %in% rownames(clytia@scale.data))
gene_accession %>% 
  filter(gene == "XLOC_007220")
```

```{r}
FeaturePlot(clytia, gene_accession$accession[gene_accession$gene == "XLOC_015054"], cols.use = viridis(256), pt.size = 0.5, reduction.use = "tsne")
```

That's one of the pan neuronal genes. Based on Jase's candidate genes, it seems that clusters 23 and 26 in my analysis (with resolution 1.6) are the neurons. 

## Clustering with different resolutions
```{r}
clytia <- clytia %>% 
  FindClusters(resolution = seq(0.6, 1.6, 0.2), dims.use = 1:60)
```

```{r}
TSNEPlot(clytia, pt.size = 0.5, group.by = "res.0.6")
```

## Marker genes for each cluster
Now I'll find marker genes for each cluster and each resolution, and see how they compare to those Jase found.
```{r}
markers <- foreach(i = seq(0.6, 1.6, 0.2)) %dopar% {
  foo <- SetAllIdent(clytia, id = paste0("res.", i))
  FindAllMarkers(foo, only.pos = TRUE, min.pct = 0.5, min.diff.pct = 0.1)
}
```

```{r}
markers_bimod <- foreach(i = seq(0.6, 1.6, 0.2)) %dopar% {
  foo <- SetAllIdent(clytia, id = paste0("res.", i))
  FindAllMarkers(foo, only.pos = TRUE, min.pct = 0.5, min.diff.pct = 0.1,
                 test.use = "bimod")
}
```

```{r}
markers_auc <- foreach(i = seq(0.6, 1.6, 0.2)) %dopar% {
  foo <- SetAllIdent(clytia, id = paste0("res.", i))
  FindAllMarkers(foo, only.pos = TRUE, min.pct = 0.5, min.diff.pct = 0.1,
                 test.use = "roc")
}
```
After filtering, which gene still has more than 1 transcripts?
```{r}
length(which(duplicated(gene_accession$gene)))
```
OK, I was right by using accession. That's not a negligible number.
```{r}
markers[[3]] %>% 
  filter(cluster == 19)
```

```{r}
FeaturePlot(clytia, "XLOC_007911", cols.use = viridis(256))
```

I take the p-value with a grain of salt, but it does seem that the Wilcoxon rank sum test gives some decent results. I did get some really good marker genes. But I'll impose more stringent criteria tto further narrow down the list of genes:

Another cool thing: see which transcripts are markers for different clusters
```{r}
markers[[3]] %>% 
  rename(accession = gene) %>% 
  left_join(gene_accession) %>% 
  dplyr::select(accession, gene) %>% 
  distinct() %>% 
  group_by(gene) %>% 
  count() %>% 
  arrange(desc(n))
```

```{r}
gene_accession %>% 
  semi_join(markers[[3]][markers[[3]]$p_val_adj < 0.05,], by = c("accession"= "gene")) %>% 
  group_by(gene) %>% 
  count() %>% arrange(desc(n))
```

Nevermind, I didn't find a gene with transcripts that are markers for different clusters. All the marker genes here only have one transcript.

1. The marker gene must not be expressed at more than a certain level in a certain number of cells in other clusters, especially large clusters (another tiny cluster also highly expressing this gene might be fine). This is to reduce background. This number depends on the size of the cluster of interest. Well, perhaps I shouldn't bring this too far; double staining can help. A combination of markers must be more helpful to identify cell types, especially for rare cell types. Well, since there aren't that many clusters, I can simply hand pick genes after inspection of plots, but I think on the long run, I should automate this since this analysis may be run several times.
2. It's fine if at a resolution, there's no marker gene for a cluster; then I should look at a coarser resolution to identify markers for a broader cell type.
3. I may try other methods of clustering, such as dropClust, and other differential expression methods, such as DEsingle. Yes, and scVI (even though, honestly, despite all that hype about deep learning, I don't really think scVI works better than its classial machine learning counterparts; I should remember that deep learning is not a panacia), but I have to fix that C++ problem.

```{r}
# Function to plot the top few marker genes in each cluster
plot_top_markers <- function(cluster = 0, nCol = 2, nGenes = 6) {
  cond <- markers$cluster == cluster & markers$p_val < 0.05
  if (sum(cond) < nGenes) nGenes <- sum(cond)
  FeaturePlot(clytia, markers[markers$cluster == cluster,
                                     "gene"][1:nGenes],
            cols.use = viridis(256), 
            pt.size = 0.5, nCol = nCol, dark.theme = TRUE)
}
```

Plot top markers for cluster 0, which seems pretty large and diffused
```{r,fig.height=8, fig.width=6, fig.align='center'}
for (i in 0:26) {
  plot_top_markers(i)
}
```

These are not always that specific.

## RNA velocity
```{r}
# Do RNA velocity
cell_dist <- as.dist(1 - armaCor(t(clytia@dr$pca@cell.embeddings), nthreads = 20))
```

```{r}
cluster_colors <- tibble(res.1 = as.character(0:24),
                         color = hue_pal()(25))
clytia@meta.data <- clytia@meta.data %>% 
  left_join(cluster_colors, by = "res.1")
colors_use <- setNames(ac(clytia@meta.data$color, alpha = 0.5),
                       colnames(clytia@scale.data))
```

```{r}
clytia_vel <- gene.relative.velocity.estimates(spliced, unspliced, cell.dist = cell_dist)
```

```{r}
show1 <- show.velocity.on.embedding.cor(emb = clytia@dr$tsne@cell.embeddings, vel = clytia_vel, show.grid.flow = TRUE, arrow.scale = 5, grid.n = 40, cell.colors = colors_use, cex = 0.5)
```

I see some big arrows on the neurons. 
```{r}
show.velocity.on.embedding.cor(emb = clytia@dr$pca@cell.embeddings[,1:2], vel = clytia_vel, cell.colors = colors_use, show.grid.flow = TRUE, arrow.scale = 5, grid.n = 40, cc = show1$cc)
```

That's an interesting pattern. The annoying part is that the velocyto package doesn't let us change the point character. Because of the black outline of the points, if I make the points smaller, they will look dark. Since velocyto doesn't let me change the color of arrows, I can't do a dark theme, since that will make it hard to see the arrows.
```{r}
show.velocity.on.embedding.cor(emb = clytia@dr$umap@cell.embeddings, vel = clytia_vel, show.grid.flow = TRUE, arrow.scale = 3, grid.n = 50, cc = show1$cc, cell.colors = colors_use, cex = 0.5)
```

```{r}
show.velocity.on.embedding.eu(emb = clytia@dr$tsne@cell.embeddings, vel = clytia_vel, arrow.scale = 3, show.cell.trajectories = TRUE, nPcs = 50)
```

```{r}
gene_accession %>% 
  filter(gene == "XLOC_044126")
```

```{r}
FeaturePlot(clytia, "XLOC_075159", cols.use = viridis(256), pt.size = 0.2, do.hover = TRUE) %>% toWebGL()
```

## Save results
```{r}
save(clytia, file = "clytia_final.RData")
```

```{r}
# Store the metadata in a way that is more convenient for plotting
bc <- str_sub(colnames(clytia@scale.data), start = 28, end = 44)
clytia_cell_attrs <- tibble(cell_names = colnames(clytia@scale.data),
                            barcode = bc,
                            nGene = clytia@meta.data$nGene,
                            nUMI = clytia@meta.data$nUMI,
                      cluster = as.factor(as.numeric(clytia@meta.data$res.1)),
                            cluster_colors = clytia@meta.data$color)
clytia_cell_attrs <- do.call(cbind, 
                      list(clytia_cell_attrs,
          setNames(as.tibble(t(clytia_loom[["col_attrs/pca_cell_embeddings"]][,])), 
                   paste0("PCA", 1:75)),
          setNames(as.tibble(t(clytia_loom[["col_attrs/tsne_cell_embeddings"]][,])),
                   paste0("tSNE", 1:2)),
          setNames(as.tibble(t(clytia_loom[["col_attrs/umap_cell_embeddings"]][,])),
                   paste0("UMAP", 1:2))))
```
```{r}
clytia_loom[["row_attrs"]]
```

```{r}
# Store gene names as a separate vector to avoid repeated query into loom
# Make it easy to index matrix by gene
clytia_gene_names <- clytia_loom[["row_attrs/gene_names"]][]
```

```{r}
# Save results
saveRDS(clytia_vel, file = "clytia_velocity_final.Rds")
saveRDS(show1, file = "clytia_show_final.Rds")
saveRDS(clytia_cell_attrs, file = "clytia_cell_attrs.Rds")
saveRDS(clytia_gene_names, file = "clytia_gene_names.Rds")
write_csv(clytia_markers, "clytia_cluster_markers.csv")
```

```{r}
clytia_scaled <- create("clytia_scaled.loom", data = clytia@scale.data)
```

Compare my marker genes with those from Jase
```{r}
markers <- readRDS("clytia_cluster_markers.rds")
markers_Jase <- read_csv("BLASTedGenesMasterList.csv")
```

```{r}
length(intersect(markers$gene, markers_Jase$Gene_ID))
```

```{r}
markers_Jase
```

Criteria for choosing genes for HCR:

1. Not already stained for
2. Detected in a sufficiently large number of cells in scRNA-seq
3. Maybe choose some genes that highlight more than 1 clusters, some that seem specific to one cluster and is expressed in most cells in that cluster, and some that seem to highlight a subcluster. There's a hierarchy of clusters.
4. We really need a good gene annotation. Then perhaps we should do GSEA for each cluster and choose genes for HCR based on the putative biological function, like genes representing certain canonical pathways.
```{r}
clytia_loom_final <- Convert(clytia, to = "loom", filename = "clytia_final.loom")
```

```{r}
clytia_loom_final$close_all()
```

